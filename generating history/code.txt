Here are some simple research code. Can you rewrite the whole code in formal production way?

First, let's think about what files are needed. For instance, we may want to specificy each data class, container, and process.

---
Certainly! Let's first take a look at the code you provided so that we can understand its functionality. This will allow us to identify the data classes, containers, and processes required to rewrite the code in a formal, production-ready way.

It looks like the provided code defines a linear optimization problem for coffee distribution. It includes the following components:

1. **Data Definitions**:
   - Capacities in suppliers
   - Shipping costs from suppliers to roasteries
   - Roasting costs (light and dark)
   - Shipping costs from roasteries to cafes
   - Light and dark coffee needed for cafes

2. **Model Creation**:
   - Defines the optimization model using Gurobi
   - Creates variables for shipping and roasting
   - Sets the objective function to minimize costs
   - Adds constraints for conservation of flow, supply, and demand
   - Optimizes the model and prints the results

To rewrite this code in a formal, production-ready way, we can break it down into the following files and classes:

### Files & Classes

1. **Data Classes**:
   - `Supplier` class: Defines the properties of a supplier (e.g., name, capacity).
   - `Roastery` class: Defines the properties of a roastery (e.g., name, roasting costs).
   - `Cafe` class: Defines the properties of a cafe (e.g., name, demand).

2. **Containers**:
   - `DistributionNetwork` class: Contains all suppliers, roasteries, and cafes, and defines the relationships and costs between them.

3. **Process Classes**:
   - `CoffeeDistributionOptimizer` class: Defines the optimization model, sets the objective function, adds constraints, and performs optimization.

4. **Main Script**:
   - Instantiates the data classes, containers, and process classes, and coordinates the optimization process.

5. **Constants Module**:
   - Defines constants such as shipping costs, roasting costs, etc.

6. **Utilities Module**:
   - Contains utility functions that might be needed, such as data validation or file reading.

7. **Tests**:
   - Unit tests for various components to ensure that the code is working correctly.

Let's start by defining the data classes, containers, and processes. If you have specific preferences or additional requirements, please let me know!

### Step 1: Define Data Classes

Here are the definitions for the data classes that represent the suppliers, roasteries, and cafes.

#### `Supplier` Class

This class represents a coffee supplier with a specific name and capacity.

```python
class Supplier:
    def __init__(self, name: str, capacity: int):
        self.name = name
        self.capacity = capacity
```

#### `Roastery` Class

This class represents a roastery with specific roasting costs for light and dark coffee.

```python
class Roastery:
    def __init__(self, name: str, roasting_cost_light: int, roasting_cost_dark: int):
        self.name = name
        self.roasting_cost_light = roasting_cost_light
        self.roasting_cost_dark = roasting_cost_dark
```

#### `Cafe` Class

This class represents a cafe with specific demands for light and dark coffee.

```python
class Cafe:
    def __init__(self, name: str, light_coffee_needed: int, dark_coffee_needed: int):
        self.name = name
        self.light_coffee_needed = light_coffee_needed
        self.dark_coffee_needed = dark_coffee_needed
```

### Step 2: Define Container

The `DistributionNetwork` class will contain all suppliers, roasteries, and cafes, and define the relationships and costs between them.

```python
class DistributionNetwork:
    def __init__(self):
        self.suppliers = []
        self.roasteries = []
        self.cafes = []
        self.shipping_cost_from_supplier_to_roastery = {}
        self.shipping_cost_from_roastery_to_cafe = {}

    def add_supplier(self, supplier: Supplier):
        self.suppliers.append(supplier)

    def add_roastery(self, roastery: Roastery):
        self.roasteries.append(roastery)

    def add_cafe(self, cafe: Cafe):
        self.cafes.append(cafe)

    def set_shipping_cost_from_supplier_to_roastery(self, supplier: Supplier, roastery: Roastery, cost: int):
        self.shipping_cost_from_supplier_to_roastery[(supplier.name, roastery.name)] = cost

    def set_shipping_cost_from_roastery_to_cafe(self, roastery: Roastery, cafe: Cafe, cost: int):
        self.shipping_cost_from_roastery_to_cafe[(roastery.name, cafe.name)] = cost
```

These classes and container provide a clear and modular way to define the coffee distribution network. Next, we will define the optimization process class. Shall we continue?

----
Let's do things step by step. Now, let's create a `supplier.py` file now, with at least 100 lines of code with details.

